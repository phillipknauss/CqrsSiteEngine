<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Ncqrs</name>
  </assembly>
  <members>
    <member name="T:Ncqrs.Domain.IDomainEventHandler">
      <summary>
            An event handler that handles the domain events.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.IDomainEventHandler.HandleEvent(Ncqrs.Domain.DomainEvent)">
      <summary>
            Handles the event.
            </summary>
      <param name="evnt">The event to handle.</param>
      <returns>
        <c>true</c> when the event was handled; otherwise, <c>false</c>.
            <remarks><c>false</c> does not mean that the handling failed, but that the 
            handler was not interested in handling this event.</remarks></returns>
      <requires description="The evnt cannot be null." exception="T:System.ArgumentNullException">evnt != null</requires>
      <exception cref="T:System.ArgumentNullException">evnt == null</exception>
    </member>
    <member name="T:Ncqrs.Config.IEnvironmentConfiguration">
      <summary>
            A configuration that can resolve requested instances.
            </summary>
    </member>
    <member name="M:Ncqrs.Config.IEnvironmentConfiguration.TryGet``1(``0@)">
      <summary>
            Tries to get the specified instance.
            </summary>
      <typeparam name="T">The type of the instance to get.</typeparam>
      <param name="result">The result.</param>
      <returns>A indication whether the instance could be get or not.</returns>
      <ensures>Contract.Result&lt;bool&gt;() ? Contract.ValueAtReturn(out result) != null : Contract.ValueAtReturn(out result) == null</ensures>
    </member>
    <member name="T:Ncqrs.Commanding.ICommand">
      <summary>
            A command message. A command should contain all the information and
            intend that is needed to execute an corresponding action.
            </summary>
    </member>
    <member name="P:Ncqrs.Commanding.ICommand.CommandIdentifier">
      <summary>
            Gets the unique identifier for this command.
            </summary>
    </member>
    <member name="T:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor">
      <summary>
            Allows users to intercept commands before or after they has been
            executed in a command service. This allows them to add additional
            behavior before or after the execution of commands. The 
            <see cref="M:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor.OnBeforeExecution(Ncqrs.Commanding.ServiceModel.CommandContext)" /> method will be called before every
            command execution and <see cref="M:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor.OnAfterExecution(Ncqrs.Commanding.ServiceModel.CommandContext)" /> will be called
            after every command execution.
            </summary>
      <example>
            The following code explains the different things that could happen in
            the context of interception.
            <code lang="c#">
            public class SampleInterceptor : ICommandServiceInterceptor
            {
                public void OnBeforeBeforeExecutorResolving(CommandContext context)
                {
                    if(context.TheCommandType == typeof(MyCommand))
                    {
                        // Convert the command to MyCommandV2.
                        MyCommand cmd = (MyCommand)context.TheCommand;
                        context.TheCommandType = MyCommandV2.CreateFrom(cmd);
                    }
                }
            
                public void OnBeforeExecution(CommandContext context)
                {
                    // Null when no executor was found for the command; otherwise, it hold
                    // the executor that will be called to execute the command after all
                    // interceptors has been called.
                    var executor = context.TheCommandExecutor;
            
                    // This is allways null in OnBeforeExecution.
                    var exception = context.Exception;
            
                    // This is allways false in OnBeforeExecution.
                    var isExecuted = context.IsExecuted;
            
                    // Holds the command that will be executed.
                    // This is never a null dereference.
                    var command = context.TheCommand;
            
                    // Holds the type of the command that will be
                    // executed. This is never a null dereference.
                    var commandType = context.TheCommandType;
                }
            
                public void OnAfterExecution(CommandContext context)
                {
                    // Null when no executor was found for the command; otherwise, it hold
                    // the executor that was called to execute the command.
                    var executor = context.TheCommandExecutor;
            
                    // If occurred, it holds the exception that was been thrown in the context; otherwise, null.
                    // Use the context.IsExecuted method to dermine whether the 
                    var exception = context.Exception;
            
                    // Holds true whenever the command executor is called to execute the command. This does
                    // not mean the execution was succesfull. Check the context.Exception method to dermine
                    // whether there was an exception on execution.
                    // When this holds false, this means the command was not executed due the fact that there
                    // was not handler found, or that an interceptor throwed an exception.
                    var isExecuted = context.IsExecuted;
            
                    // Holds the command that was been executed.
                    var command = context.TheCommand;
            
                    // Holds the type of the command that will be
                    // executed. This is never a null dereference.
                    var commandType = context.TheCommandType;
                }
            }
            </code></example>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor.OnBeforeBeforeExecutorResolving(Ncqrs.Commanding.ServiceModel.CommandContext)">
      <summary>
            Intercepts a command execution before the command executor is
            resolved.
            <para>In this method the interceptor may override the command by
            setting the <see cref="P:Ncqrs.Commanding.ServiceModel.CommandContext.TheCommand" /> property.</para></summary>
      <param name="context">The context of the current command execution.
            </param>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor.OnBeforeExecution(Ncqrs.Commanding.ServiceModel.CommandContext)">
      <summary>
            Intercepts a command execution before the command will be executed,
            but after the executor has been resolved.
            </summary>
      <param name="context">The context of the current command execution.
            </param>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor.OnAfterExecution(Ncqrs.Commanding.ServiceModel.CommandContext)">
      <summary>
            Intercepts a command execution when a exception has been occurred or
            after the command has been executed. See the 
            <see cref="P:Ncqrs.Commanding.ServiceModel.CommandContext.ExecutorHasBeenCalled" /> to determine whether the
            command has been executed.
            </summary>
      <param name="context">The context of the current command
            execution.
            </param>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Actions.ObjectCreationCommandExecutor`1">
      <summary>
            An auto mapped action for a command. It created the object as specified by the mapping.
            </summary>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.ICommandExecutor`1">
      <summary>
            Executes a command. This means that the handles 
            executes the correct action based on the command.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.ICommandExecutor`1.Execute(`0)">
      <summary>
            Executes the command.
            </summary>
      <param name="command">The command to execute. This should not be null.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <i>command</i> is null.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Actions.ObjectCreationCommandExecutor`1.Execute(`0)">
      <summary>
            Executes this action.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.SQL.SimpleMicrosoftSqlServerEventStore">
      <summary>
            Stores events for a SQL database.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.IEventStore">
      <summary>
            A event store. Can store and load events from an <see cref="T:Ncqrs.Eventing.IEventSource" />.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.IEventStore.GetAllEvents(System.Guid)">
      <summary>
            Get all events provided by an specified event provider.
            </summary>
      <param name="id">The id of the event source that owns the events.</param>
      <returns>All the events from the event source.</returns>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.IEventStore.GetAllEventsSinceVersion(System.Guid,System.Int64)">
      <summary>
            Get all events provided by an specified event source.
            </summary>
      <param name="eventSourceId">The id of the event source that owns the events.</param>
      <returns>All the events from the event source.</returns>
      <ensures>Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ISourcedEvent&gt;&gt;(), e =&gt; e.EventSequence &gt; version)</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.IEventStore.Save(Ncqrs.Eventing.IEventSource)">
      <summary>
            Save all events from a specific event provider.
            </summary>
      <exception cref="T:Ncqrs.Eventing.Storage.ConcurrencyException">Occurs when there is already a newer version of the event provider stored in the event store.</exception>
      <param name="source">The source that should be saved.</param>
      <requires description="source cannot be null." exception="T:System.ArgumentNullException">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.ISnapshotStore.SaveShapshot(Ncqrs.Eventing.ISnapshot)">
      <summary>
            Saves a snapshot of the specified event source.
            </summary>
      <requires description="The source cannot be null." exception="T:System.ArgumentNullException">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.ISnapshotStore.GetSnapshot(System.Guid)">
      <summary>
            Gets a snapshot of a particular event source, if one exists. Otherwise, returns <c>null</c>.
            </summary>
      <ensures>Contract.Result&lt;ISnapshot&gt;() != null ? Contract.Result&lt;ISnapshot&gt;().EventSourceId == eventSourceId : true</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.SimpleMicrosoftSqlServerEventStore.GetAllEvents(System.Guid)">
      <summary>
            Get all event for a specific event provider.
            </summary>
      <param name="id">The id of the event provider.</param>
      <returns>All events for the specified event provider.</returns>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.SimpleMicrosoftSqlServerEventStore.GetAllEventsSinceVersion(System.Guid,System.Int64)">
      <summary>
            Get all events provided by an specified event source.
            </summary>
      <param name="eventSourceId">The id of the event source that owns the events.</param>
      <returns>All the events from the event source.</returns>
      <ensures inheritedFrom="M:Ncqrs.Eventing.Storage.IEventStore.GetAllEventsSinceVersion(System.Guid,System.Int64)" inheritedFromTypeName="IEventStore">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ISourcedEvent&gt;&gt;(), e =&gt; e.EventSequence &gt; version)</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.SimpleMicrosoftSqlServerEventStore.Save(Ncqrs.Eventing.IEventSource)">
      <summary>
            Saves all events from an event provider.
            </summary>
      <param name="provider">The eventsource.</param>
      <requires description="source cannot be null." inheritedFrom="M:Ncqrs.Eventing.Storage.IEventStore.Save(Ncqrs.Eventing.IEventSource)" inheritedFromTypeName="IEventStore" exception="T:System.ArgumentNullException">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.SimpleMicrosoftSqlServerEventStore.SaveShapshot(Ncqrs.Eventing.ISnapshot)">
      <summary>
            Saves a snapshot of the specified event source.
            </summary>
      <requires description="The source cannot be null." inheritedFrom="M:Ncqrs.Eventing.Storage.ISnapshotStore.SaveShapshot(Ncqrs.Eventing.ISnapshot)" inheritedFromTypeName="ISnapshotStore" exception="T:System.ArgumentNullException">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.SimpleMicrosoftSqlServerEventStore.GetSnapshot(System.Guid)">
      <summary>
            Gets a snapshot of a particular event source, if one exists. Otherwise, returns <c>null</c>.
            </summary>
      <ensures inheritedFrom="M:Ncqrs.Eventing.Storage.ISnapshotStore.GetSnapshot(System.Guid)" inheritedFromTypeName="ISnapshotStore">Contract.Result&lt;ISnapshot&gt;() != null ? Contract.Result&lt;ISnapshot&gt;().EventSourceId == eventSourceId : true</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.SimpleMicrosoftSqlServerEventStore.SaveEvents(System.Collections.Generic.IEnumerable{Ncqrs.Eventing.ISourcedEvent},System.Guid,System.Data.SqlClient.SqlTransaction)">
      <summary>
            Saves the events to the event store.
            </summary>
      <param name="evnts">The events to save.</param>
      <param name="eventSourceId">The event source id that owns the events.</param>
      <param name="transaction">The transaction.</param>
      <requires description="The argument evnts could not be null." exception="T:System.ArgumentNullException">evnts != null</requires>
      <exception cref="T:System.ArgumentNullException">evnts == null</exception>
      <requires description="The argument transaction could not be null." exception="T:System.ArgumentNullException">transaction != null</requires>
      <exception cref="T:System.ArgumentNullException">transaction == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.SimpleMicrosoftSqlServerEventStore.SaveEvent(Ncqrs.Eventing.ISourcedEvent,System.Guid,System.Data.SqlClient.SqlTransaction)">
      <summary>
            Saves the event to the data store.
            </summary>
      <param name="evnt">The event to save.</param>
      <param name="eventSourceId">The id of the event source that owns the event.</param>
      <param name="transaction">The transaction.</param>
      <requires description="The argument evnt could not be null." exception="T:System.ArgumentNullException">evnt != null</requires>
      <exception cref="T:System.ArgumentNullException">evnt == null</exception>
      <requires description="The argument transaction could not be null." exception="T:System.ArgumentNullException">transaction != null</requires>
      <exception cref="T:System.ArgumentNullException">transaction == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.SimpleMicrosoftSqlServerEventStore.AddEventSource(Ncqrs.Eventing.IEventSource,System.Data.SqlClient.SqlTransaction)">
      <summary>
            Adds the event source to the event store.
            </summary>
      <param name="eventSource">The event source to add.</param>
      <param name="transaction">The transaction.</param>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.SimpleMicrosoftSqlServerEventStore.GetVersion(System.Guid,System.Data.SqlClient.SqlTransaction)">
      <summary>
            Gets the version of the provider from the event store.
            </summary>
      <param name="providerId">The provider id.</param>
      <param name="transaction">The transaction.</param>
      <returns>A <see cref="!:int?" /> that is <c>null</c> when no version was known ; otherwise,
            it contains the version number.</returns>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.SimpleMicrosoftSqlServerEventStore.GetTableCreationQueries">
      <summary>
            Gets the table creation queries that can be used to create the tables that are needed
            for a database that is used as an event store.
            </summary>
      <remarks>This returns the content of the TableCreationScript.sql that is embedded as resource.</remarks>
      <returns>Queries that contain the <i>create table</i> statements.</returns>
    </member>
    <member name="T:Ncqrs.Domain.Storage.IDomainRepository">
      <summary>
            A repository that can be used to get and save aggregate roots.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.Storage.IDomainRepository.GetById(System.Type,System.Guid)">
      <summary>
            Gets aggregate root by id.
            </summary>
      <param name="aggregateRootType">Type of the aggregate root.</param>
      <param name="id">The id of the aggregate root.</param>
      <returns>A new instance of the aggregate root that contains the latest known state.</returns>
      <requires exception="T:System.ArgumentNullException">aggregateRootType != null</requires>
      <exception cref="T:System.ArgumentNullException">aggregateRootType == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.Storage.IDomainRepository.GetById``1(System.Guid)">
      <summary>
            Gets aggregate root by id.
            </summary>
      <typeparam name="T">The type of the aggregate root.</typeparam>
      <param name="id">The id of the aggregate root.</param>
      <returns>A new instance of the aggregate root that contains the latest known state.</returns>
    </member>
    <member name="M:Ncqrs.Domain.Storage.IDomainRepository.Save(Ncqrs.Domain.AggregateRoot)">
      <summary>
            Saves the specified aggregate root.
            </summary>
      <param name="aggregateRootToSave">The aggregate root to save.</param>
      <requires exception="T:System.ArgumentNullException">aggregateRootToSave != null</requires>
      <exception cref="T:System.ArgumentNullException">aggregateRootToSave == null</exception>
    </member>
    <member name="T:Ncqrs.Domain.AggregateRoot">
      <summary>
            The abstract concept of an aggregate root.
            </summary>
      <invariant description="The member _unacceptedEvents should never be null.">_uncommittedEvent != null</invariant>
    </member>
    <member name="T:Ncqrs.Eventing.IEventSource">
      <summary>
            An object that represents all his state changes via a sequence of events.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.IEventSource.GetUncommittedEvents">
      <summary>
            Gets the uncommitted events.
            </summary>
      <returns />
    </member>
    <member name="M:Ncqrs.Eventing.IEventSource.AcceptChanges">
      <summary>
            Commits the events.
            </summary>
    </member>
    <member name="P:Ncqrs.Eventing.IEventSource.Id">
      <summary>
            Gets the globally unique identifier.
            </summary>
    </member>
    <member name="P:Ncqrs.Eventing.IEventSource.Version">
      <summary>
            Gets the current version of the instance as it is known in the event store.
            </summary>
      <value>An <see cref="T:System.Int64" /> representing the current version of this aggregate root.</value>
    </member>
    <member name="P:Ncqrs.Eventing.IEventSource.InitialVersion">
      <summary>
            Gets the initial version.
            <para>
            This represents the current version of this instance. When this instance was retrieved
            via history, it contains the version as it was at that time. For new instances this value is always 0.
            </para><para>
            The version does not change until changes are accepted via the <see cref="M:Ncqrs.Eventing.IEventSource.AcceptChanges" /> method.
            </para></summary>
      <value>The initial version.</value>
    </member>
    <member name="F:Ncqrs.Domain.AggregateRoot._uncommittedEvent">
      <summary>
            Holds the events that are not yet committed.
            </summary>
    </member>
    <member name="F:Ncqrs.Domain.AggregateRoot._eventHandlers">
      <summary>
            A list that contains all the event handlers.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.AggregateRoot.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Domain.AggregateRoot" /> class.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.AggregateRoot.InitializeFromHistory(System.Collections.Generic.IEnumerable{Ncqrs.Domain.DomainEvent})">
      <summary>
            Initializes from history.
            </summary>
      <param name="history">The history.</param>
      <requires description="The history cannot be null." exception="T:System.ArgumentNullException">history != null</requires>
      <exception cref="T:System.ArgumentNullException">history == null</exception>
    </member>
    <member name="P:Ncqrs.Domain.AggregateRoot.Id">
      <summary>
            Gets the globally unique identifier.
            </summary>
      <exception cref="T:System.InvalidOperationException">Thrown when setting this
            value when the version of this aggregate root is not 0 or this
            instance contains are any uncommitted events.</exception>
      <setter>
        <requires exception="T:System.InvalidOperationException">Version == 0</requires>
        <requires exception="T:System.InvalidOperationException">_uncommittedEvent.Count == 0</requires>
      </setter>
      <exception cref="T:System.InvalidOperationException">Version != 0</exception>
      <exception cref="T:System.InvalidOperationException">_uncommittedEvent.Count != 0</exception>
    </member>
    <member name="P:Ncqrs.Domain.AggregateRoot.Version">
      <summary>
            Gets the current version of the instance as it is known in the event store.
            </summary>
      <value>
            An <see cref="T:System.Int64" /> representing the current version of this aggregate root.
            </value>
    </member>
    <member name="P:Ncqrs.Domain.AggregateRoot.InitialVersion">
      <summary>
            Gets the initial version.
            <para>
            This represents the current version of this instance. When this instance was retrieved
            via history, it contains the version as it was at that time. For new instances this value is always 0.
            </para><para>
            The version does not change until changes are accepted via the <see cref="M:Ncqrs.Domain.AggregateRoot.AcceptChanges" /> method.
            </para></summary>
      <value>The initial version.</value>
      <setter>
        <requires exception="T:System.InvalidOperationException">_uncommittedEvent.Count == 0</requires>
      </setter>
      <exception cref="T:System.InvalidOperationException">_uncommittedEvent.Count != 0</exception>
    </member>
    <member name="T:Ncqrs.Domain.Mapping.ConventionBasedDomainEventHandlerMappingStrategy">
      <summary>
            A internal event handler mapping strategy that maps methods as an event handler based on method name and parameter type.
            <remarks>
            All method that match the following requirements are mapped as an event handler:
            <list type="number"><item><value>
                        Method name should start with <i>On</i> or <i>on</i>. Like: <i>OnProductAdded</i> or <i>onProductAdded</i>.
                    </value></item><item><value>
                        The method should only accept one parameter.
                    </value></item><item><value>
                        The parameter must be, or inhired from, the <see cref="T:Ncqrs.Domain.DomainEvent" /> class.
                    </value></item></list></remarks></summary>
    </member>
    <member name="T:Ncqrs.NcqrsEnvironment">
      <summary>The Ncqrs environment. This class gives access to other components registered in this environment.
            <remarks>
            Make sure to call the <see cref="M:Ncqrs.NcqrsEnvironment.Configure(Ncqrs.Config.IEnvironmentConfiguration)" /> method before doing anything else with this class.
            </remarks></summary>
    </member>
    <member name="F:Ncqrs.NcqrsEnvironment._defaults">
      <summary>
            Holds the defaults for requested types that are not configured.
            </summary>
      <remarks>
            Use the <see cref="M:Ncqrs.NcqrsEnvironment.SetDefault``1(``0)" /> method to set a default.
            </remarks>
    </member>
    <member name="F:Ncqrs.NcqrsEnvironment._instance">
      <summary>
            Hold the environment configuration. This is initialized by the <see cref="M:Ncqrs.NcqrsEnvironment.Configure(Ncqrs.Config.IEnvironmentConfiguration)" /> method.
            </summary>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironment.Get``1">
      <summary>
            Gets or create the requested instance specified by the parameter <typeparamref name="T" />.
            </summary>
      <remarks>This</remarks>
      <typeparam name="T">The type of the instance that is requested.
            </typeparam>
      <returns>If the type specified by <typeparamref name="T" /> is
            registered, it returns an instance that is, is a super class of, or
            implements the type specified by <typeparamref name="T" />. Otherwise
            a <see cref="T:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException" />
            occurs.
            </returns>
      <ensures description="The result cannot be null.">Contract.Result&lt;T&gt;() != null</ensures>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironment.SetDefault``1(``0)">
      <summary>
            Sets the default for an type. This default instance is returned when
            the configured <see cref="T:Ncqrs.Config.IEnvironmentConfiguration" /> did not
            returned an instance for this type.
            </summary>
      <remarks>When the type already contains a default, it is overridden.
            </remarks>
      <typeparam name="T">The type of the instance to set a default.
            </typeparam>
      <param name="instance">The instance to set as default.</param>
      <requires description="The instance cannot be null." exception="T:System.ArgumentNullException">instance != null</requires>
      <exception cref="T:System.ArgumentNullException">instance == null</exception>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironment.RemoveDefault``1">
      <summary>
            Removes the default for specified type.
            </summary>
      <remarks>When there is no default set, this action is ignored.</remarks>
      <typeparam name="T">The registered default type.</typeparam>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironment.Configure(Ncqrs.Config.IEnvironmentConfiguration)">
      <summary>
            Configures the Ncqrs environment.
            </summary>
      <param name="source">The source that contains the configuration for the current environment.</param>
      <requires description="The source cannot be null." exception="T:System.ArgumentNullException">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
      <requires description="Cannot configure the environment when it is already configured." exception="T:System.InvalidOperationException">!IsConfigured</requires>
      <exception cref="T:System.InvalidOperationException">IsConfigured</exception>
      <ensures description="The given source should initialize the _instance member.">_instance == source</ensures>
      <ensures description="The given source should configure this environment.">IsConfigured</ensures>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironment.Deconfigure">
      <summary>
            When the environment is configured it removes the configuration. Defaults are not removed.
            </summary>
    </member>
    <member name="P:Ncqrs.NcqrsEnvironment.IsConfigured">
      <summary>
            Gets a value indicating whether this environment is configured.
            </summary>
      <value>
        <c>true</c> if this environment is configured; otherwise, <c>false</c>.
            </value>
    </member>
    <!-- Badly formed XML comment ignored for member "T:Ncqrs.Domain.Mapping.ExpressionBasedDomainEventHandlerMappingStrategy" -->
    <member name="M:Ncqrs.Domain.Mapping.ExpressionBasedDomainEventHandlerMappingStrategy.GetEventHandlersFromAggregateRoot(Ncqrs.Domain.AggregateRootMappedWithExpressions)">
      <summary>
            Gets the event handlers from aggregate root based on the given mapping.
            </summary>
      <param name="aggregateRoot">The aggregate root.</param>
      <see cref="T:Ncqrs.Domain.Mapping.ExpressionBasedDomainEventHandlerMappingStrategy" />
      <returns>All the <see cref="T:Ncqrs.Domain.IDomainEventHandler" />'s created based on the given mapping.</returns>
      <requires description="The aggregateRoot cannot be null." exception="T:System.ArgumentNullException">aggregateRoot != null</requires>
      <exception cref="T:System.ArgumentNullException">aggregateRoot == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.Mapping.ExpressionBasedDomainEventHandlerMappingStrategy.CreateHandlerForMethod(Ncqrs.Domain.AggregateRoot,System.Reflection.MethodInfo,System.Boolean)">
      <summary>
            Converts the given method into an <see cref="T:Ncqrs.Domain.IDomainEventHandler" /> object.
            </summary>
      <param name="aggregateRoot">The aggregateroot from which we want to invoke the method.</param>
      <param name="method">The method to invoke</param>
      <param name="exact">
        <b>True</b> if we need to have an exact match, otherwise <b>False</b>.</param>
      <returns>An <see cref="T:Ncqrs.Domain.IDomainEventHandler" /> that handles the execution of the given method.</returns>
    </member>
    <member name="T:Ncqrs.Eventing.ServiceModel.Bus.IEventBus">
      <summary>
            A bus that can publish events to handlers.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.ServiceModel.Bus.IEventBus.Publish(Ncqrs.Eventing.IEvent)">
      <summary>
            Publishes the event to the handlers.
            </summary>
      <param name="eventMessage">The message to publish.</param>
      <exception cref="T:System.ArgumentNullException">Thrown when <i>message</i> was null.</exception>
      <exception cref="!:NoHandlerRegisteredForMessageException">Thrown when no handler was found for the specified message.</exception>
    </member>
    <member name="M:Ncqrs.Eventing.ServiceModel.Bus.IEventBus.Publish(System.Collections.Generic.IEnumerable{Ncqrs.Eventing.IEvent})">
      <summary>
            Publishes the messages to the handlers.
            </summary>
      <param name="eventMessage">The messages to publish.</param>
      <exception cref="T:System.ArgumentNullException">Thrown when <i>messages</i> was null.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown when a instance in <i>messages</i> was null.</exception>
      <exception cref="!:NoHandlerRegisteredForMessageException">Thrown when no handler was found for one of the specified messages.</exception>
    </member>
    <member name="M:Ncqrs.Eventing.ServiceModel.Bus.IEventBus.RegisterHandler``1(Ncqrs.Eventing.ServiceModel.Bus.IEventHandler{``0})">
      <summary>
            Register a handler that will receive all messages that are published.
            </summary>
      <param name="handler">The handler to register.</param>
    </member>
    <member name="T:Ncqrs.NamespaceDoc">
      <summary>
            This namespace contains the components of the Ncqrs framework. The framework is devided in tree main sections. 
            <para><b>Commanding</b> is the section where everything related to commands, command execution and command services can be found.
            </para><para><b>Domain</b> is the section where everything related to the domain can be found. In this section you find things like
            <see cref="T:Ncqrs.Domain.AggregateRoot" /> and the <see cref="T:Ncqrs.Domain.Storage.IDomainRepository" />.
            </para><para><b>Eventing</b> is the section where everything related to events, denormalization and event services can be found.
            </para><para>For more information about the framework, visit <seealso cref="!:http://ncqrs.org">ncqrs.org</seealso> or visit the 
            <seealso cref="!:http://blog.ncqrs.org">blog</seealso>.</para></summary>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.ExcludeInMappingAttribute">
      <summary>
            Defines that a property should be excluded in the auto mapping process.
            </summary>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.AggregateRootIdAttribute">
      <summary>
            Marks a property as the property that contains the aggregate root id.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.ISourcedEvent">
      <summary>
            An event that is sourced by an event source. This event source represents all hist state changes via these events.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.IEvent">
      <summary>
            Represents an event.
            </summary>
    </member>
    <member name="P:Ncqrs.Eventing.IEvent.EventIdentifier">
      <summary>
            Gets the unique identifier for this event.
            </summary>
      <value>A <see cref="T:System.Guid" /> that represents the unique identifier of this event.</value>
    </member>
    <member name="P:Ncqrs.Eventing.IEvent.EventTimeStamp">
      <summary>
            Gets the time stamp for this event.
            </summary>
      <value>a <see cref="T:System.DateTime" /> UTC value that represents the point
            in time where this event occurred.</value>
      <getter>
        <ensures description="The event time stamp should always be in a UTC kind.">Contract.Result&lt;DateTime&gt;().Kind == DateTimeKind.Utc</ensures>
      </getter>
    </member>
    <member name="P:Ncqrs.Eventing.ISourcedEvent.EventSourceId">
      <summary>
            Gets the id of the event source that owns this event.
            </summary>
      <value>The id of the event source that owns this event.</value>
    </member>
    <member name="P:Ncqrs.Eventing.ISourcedEvent.EventSequence">
      <summary>
            Gets the event sequence number.
            </summary>
      <value>A number that represents the order of where this events occurred in the sequence.</value>
    </member>
    <member name="M:Ncqrs.Domain.DomainEvent.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Domain.DomainEvent" /> class.
            </summary>
      <remarks>This initializes the <see cref="P:Ncqrs.Domain.DomainEvent.EventIdentifier" /> with the
            value from the <see cref="T:Ncqrs.IUniqueIdentifierGenerator" /> and the 
            <see cref="P:Ncqrs.Domain.DomainEvent.EventTimeStamp" /> with the value from the 
            <see cref="T:Ncqrs.IClock" /> that is gotten from the 
            <see cref="T:Ncqrs.NcqrsEnvironment" />.</remarks>
    </member>
    <member name="M:Ncqrs.Domain.DomainEvent.#ctor(System.Guid,System.Guid,System.Int64,System.DateTime)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Domain.DomainEvent" /> class.
            </summary>
      <param name="eventIdentifier">The event identifier.</param>
      <param name="aggregateRootId">The aggregate root id.</param>
      <param name="eventSequence">The event sequence.</param>
      <param name="eventTimeStamp">The event time stamp.</param>
    </member>
    <member name="P:Ncqrs.Domain.DomainEvent.EventIdentifier">
      <summary>
            Gets the unique identifier for this event.
            </summary>
      <value />
    </member>
    <member name="P:Ncqrs.Domain.DomainEvent.AggregateRootId">
      <summary>
            Gets the aggregate root id.
            </summary>
      <value>The aggregate root id of the one that owns this event.</value>
    </member>
    <member name="P:Ncqrs.Domain.DomainEvent.EventSequence">
      <summary>
            Gets the event sequence.
            </summary>
      <value>A number that represents the number of this event in the sequence.</value>
    </member>
    <member name="P:Ncqrs.Domain.DomainEvent.EventTimeStamp">
      <summary>
            Gets the time stamp for this event.
            </summary>
      <value>
            a <see cref="T:System.DateTime" /> UTC value that represents the point
            in time where this event occurred.
            </value>
      <getter>
        <ensures description="The event time stamp should always be in a UTC kind." inheritedFrom="M:Ncqrs.Eventing.IEvent.get_EventTimeStamp" inheritedFromTypeName="IEvent">Contract.Result&lt;DateTime&gt;().Kind == DateTimeKind.Utc</ensures>
      </getter>
    </member>
    <member name="P:Ncqrs.Domain.DomainEvent.Ncqrs#Eventing#ISourcedEvent#EventSourceId">
      <summary>
            Gets the id of the event source that owns this event.
            </summary>
      <value>The id of the event source that owns this event. This value is always the same as <see cref="P:Ncqrs.Domain.DomainEvent.AggregateRootId" />.</value>
    </member>
    <member name="T:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException">
      <summary>
            Occurs when a requested instance could not be found in the Ncqrs environment configuration.
            </summary>
    </member>
    <member name="T:Ncqrs.NcqrsEnvironmentException">
      <summary>
            Occurs when there was an exception in the Ncqrs environment configuration.
            </summary>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironmentException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.NcqrsEnvironmentException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironmentException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.NcqrsEnvironmentException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="inner">The inner.</param>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironmentException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.NcqrsEnvironmentException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="M:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException" /> class.
            </summary>
      <param name="requestedType">Type of the requested instance.</param>
    </member>
    <member name="M:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException.#ctor(System.Type,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException" /> class.
            </summary>
      <param name="requestedType">Type of the requested instance.</param>
      <param name="message">The message.</param>
    </member>
    <member name="M:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException.#ctor(System.Type,System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException" /> class.
            </summary>
      <param name="requestedType">Type of the requested instance.</param>
      <param name="message">The message.</param>
      <param name="inner">The inner exception.</param>
    </member>
    <member name="M:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException.RequestedType">
      <summary>
            Gets the type of the requested instance.
            </summary>
      <value>The type of the requested instance.</value>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.CommandExecutorNotFoundException">
      <summary>
            Occurs when no executor was not found to execute the command.
            </summary>
      <invariant>CommandType != null</invariant>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.CommandExecutorNotFoundException.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.CommandExecutorNotFoundException" /> class.
            </summary>
      <param name="commandType">Type of the command.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <i>commandType</i> is a <c>null</c> dereference.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.CommandExecutorNotFoundException.#ctor(System.Type,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.CommandExecutorNotFoundException" /> class.
            </summary>
      <param name="commandType">Type of the command.</param>
      <param name="message">The message.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <i>commandType</i> is a <c>null</c> dereference.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.CommandExecutorNotFoundException.#ctor(System.Type,System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.CommandExecutorNotFoundException" /> class.
            </summary>
      <param name="commandType">Type of the command.</param>
      <param name="message">The message.</param>
      <param name="inner">The inner exception.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <i>commandType</i> is a <c>null</c> dereference.</exception>
      <requires exception="T:System.ArgumentNullException">commandType != null</requires>
      <exception cref="T:System.ArgumentNullException">commandType == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.CommandExecutorNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.CommandExecutorNotFoundException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.CommandExecutorNotFoundException.CommandType">
      <summary>
            Gets the type of the command.
            </summary>
    </member>
    <member name="T:Ncqrs.BasicGuidGenerator">
      <summary>
            An unique identifier generator based on the .NET <see cref="T:System.Guid" /> class.
            </summary>
    </member>
    <member name="T:Ncqrs.IUniqueIdentifierGenerator">
      <summary>
            Generator that generates unique identifiers.
            </summary>
    </member>
    <member name="M:Ncqrs.IUniqueIdentifierGenerator.GenerateNewId">
      <summary>
            Generates the new identifier.
            </summary>
      <returns>A new <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Ncqrs.BasicGuidGenerator.GenerateNewId">
      <summary>
            Generates a new <see cref="T:System.Guid" /> based on the <see cref="M:System.Guid.NewGuid" /> method.
            </summary>
      <returns>A new generated <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.TransactionalCommandExecutorWrapper`1">
      <summary>
            Wraps transactional behavior around the execution of command executor.
            </summary>
      <remarks>
            The transaction logic uses <c>TransactionScope</c> of the .NET framework.
            </remarks>
    </member>
    <member name="F:Ncqrs.Commanding.CommandExecution.TransactionalCommandExecutorWrapper`1._executor">
      <summary>
            The executor to use to execute the command.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.TransactionalCommandExecutorWrapper`1.#ctor(Ncqrs.Commanding.CommandExecution.ICommandExecutor{`0})">
      <summary>
            Initializes a new instance of the <see cref="!:TransactionalCommandExecutorWrapper" /> class.
            </summary>
      <param name="executor">The executor to use to execute the command.</param>
      <requires description="The executor cannot be null." exception="T:System.ArgumentNullException">executor != null</requires>
      <exception cref="T:System.ArgumentNullException">executor == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.TransactionalCommandExecutorWrapper`1.Execute(`0)">
      <summary>
            Executes the command within a transaction. The transaction logic uses TransactionScope.
            </summary>
      <param name="command">The command to execute. This should not be null.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <i>command</i> is null.</exception>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.MappedCommandExecutor`1">
      <summary>
            A command handler that execute an action based on the mapping of a command.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.MappedCommandExecutor`1.Execute(`0)">
      <summary>
            Executes the command.
            </summary>
      <param name="command">The command to execute. This should not be null.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <i>command</i> is null.</exception>
    </member>
    <member name="T:Ncqrs.Domain.AggregateRootMappedWithExpressions">
      <summary>
            A aggregate root that uses lambda style mapping to map internal event handlers. The following method should be mapped 
            </summary>
      <remarks>
            This aggregate root uses the  <see cref="T:Ncqrs.Domain.Mapping.ExpressionBasedDomainEventHandlerMappingStrategy" /> to get the internal event handlers.
            </remarks>
      <seealso cref="T:Ncqrs.Domain.Mapping.ExpressionBasedDomainEventHandlerMappingStrategy" />
    </member>
    <member name="M:Ncqrs.Domain.AggregateRootMappedWithExpressions.Map``1">
      <summary>
            Maps the given generic eventtype to the expressed handler.
            </summary>
      <typeparam name="T">This should always be a <see cref="T:Ncqrs.Domain.DomainEvent" />.</typeparam>
      <returns>An <see cref="T:Ncqrs.Domain.Mapping.ExpressionHandler`1" />which allows us to define the mapping to a handler.</returns>
    </member>
    <member name="M:Ncqrs.Domain.AggregateRootMappedWithExpressions.InitializeEventHandlers">
      <summary>
             Defines the method that derived types need to implement to support strongly typed mapping.
            </summary>
    </member>
    <member name="P:Ncqrs.Domain.AggregateRootMappedWithExpressions.MappingHandlers">
      <summary>
            Gets the <see cref="T:System.Collections.Generic.IList`1" /> list of mapping rules.
            </summary>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootMethodAttribute">
      <summary>
            Defines that the command maps directly to a method on an aggregate root.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootMethodAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootMethodAttribute" /> class.
            </summary>
      <param name="typeName">Name of the type.</param>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootMethodAttribute.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootMethodAttribute" /> class.
            </summary>
      <param name="typeName">Name of the type.</param>
      <param name="methodName">Name of the method.</param>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootMethodAttribute.TypeName">
      <summary>
            Get or sets the full qualified type name of the target aggregate root.
            </summary>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootMethodAttribute.MethodName">
      <summary>
            Get or sets the full qualified name of the target method.
            </summary>
      <remarks>Leave this null or empty to automap the target method based on the command name.</remarks>
    </member>
    <member name="T:Ncqrs.Commanding.ServiceModel.CommandContext">
      <summary>Represents the context of a command execution in an 
            <see cref="T:Ncqrs.Commanding.ServiceModel.ICommandService" />. This context is passed through 
            <see cref="T:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor">interceptors</see> for each
            interception.</summary>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.CommandContext.#ctor(Ncqrs.Commanding.ICommand)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.ServiceModel.CommandContext" /> class.
            </summary>
      <param name="theCommand">The command that will be executed.</param>
      <requires description="The theCommand cannot be null." exception="T:System.ArgumentNullException">theCommand != null</requires>
      <exception cref="T:System.ArgumentNullException">theCommand == null</exception>
    </member>
    <member name="P:Ncqrs.Commanding.ServiceModel.CommandContext.Exception">
      <summary>
        <para>Gets the exception that has occurred while handling the event.
            Use the <see cref="P:Ncqrs.Commanding.ServiceModel.CommandContext.ExecutorHasBeenCalled" /> property to determine whether
            the exception has been thrown by a interceptor or by the execution
            itself.</para>
      </summary>
      <value>The exception that has been occurred or <c>null</c> when it
            has not.</value>
    </member>
    <member name="P:Ncqrs.Commanding.ServiceModel.CommandContext.ExecutorResolved">
      <summary>
            Gets a value indicating whether an executor has been resolved.
            </summary>
      <value>
        <c>true</c> if an executor has been resolved for this command; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Ncqrs.Commanding.ServiceModel.CommandContext.TheCommand">
      <summary>
            Gets the command that will be or is executed.
            </summary>
      <exception cref="T:System.InvalidOperationException">Occurs when this
            property is set while the <see cref="P:Ncqrs.Commanding.ServiceModel.CommandContext.ExecutorResolved" /> property
            return true indicating that a executor has been resolved for the command.</exception>
      <value>The command that will or has been executed. This value is never <c>null</c>.</value>
      <getter>
        <ensures description="The result cannot be null.">Contract.Result&lt;ICommand&gt;() != null</ensures>
      </getter>
      <setter>
        <requires description="Cannot override command when a command executor has already been resolved." exception="T:System.InvalidOperationException">!ExecutorResolved</requires>
      </setter>
      <exception cref="T:System.InvalidOperationException">ExecutorResolved</exception>
    </member>
    <member name="P:Ncqrs.Commanding.ServiceModel.CommandContext.TheCommandType">
      <summary>
            Gets the type of the command.
            </summary>
      <value>The type of the command.</value>
    </member>
    <member name="P:Ncqrs.Commanding.ServiceModel.CommandContext.ExecutorHasBeenCalled">
      <summary>
            Gets a value indicating whether the executor for the command has
            been called.
            </summary>
      <value>
        <c>true</c> if the executor for this command has been called;
            	otherwise, <c>false</c>. <c>true</c> does not have to mean that the
            	executor also executed the command. It could be that an exception
            	had occurred.
            <remarks>
            This value is always <c>false</c> in the 
            <see cref="M:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor.OnBeforeExecution(Ncqrs.Commanding.ServiceModel.CommandContext)" />.
            </remarks></value>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootConstructorAttribute">
      <summary>
            Defines that the command maps directly to a constructor on an aggregate root.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootConstructorAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootConstructorAttribute" /> class.
            </summary>
      <param name="typeName">The full qualified name of the type of the aggregate root.</param>
      <exception cref="T:System.ArgumentNullException">Thrown when <i>typeName</i> is null or emtpy.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootConstructorAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootConstructorAttribute" /> class.
            </summary>
      <param name="type">The type of the aggregate root.</param>
      <exception cref="T:System.ArgumentNullException">Thrown when <i>type</i> is null.</exception>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootConstructorAttribute.TypeName">
      <summary>
            Get or sets the full qualified type name of the target aggregate root.
            </summary>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.MappingForCommandNotFoundException">
      <summary>
            Occurs when there is no auto mapping found for a <see cref="T:Ncqrs.Commanding.ICommand" />.
            </summary>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingException">
      <summary>
            Occurs when the mapping of a command is invalid.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingException" /> class with a specified error message.
            </summary>
      <param name="message">The message that describes the error. </param>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception. </param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified. </param>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingException" /> class with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown. </param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination. </param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.MappingForCommandNotFoundException.#ctor(System.String,Ncqrs.Commanding.ICommand)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.MappingForCommandNotFoundException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="command">The command.</param>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.MappingForCommandNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.MappingForCommandNotFoundException" /> class with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown. </param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination. </param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.Mapping.MappingForCommandNotFoundException.Command">
      <summary>
            Gets the command.
            </summary>
      <value>The command.</value>
    </member>
    <member name="T:Ncqrs.Domain.Mapping.NoEventHandlerAttribute">
      <summary>
            Specifies that the method is not an event handler. Use this attribute to exclude the
            method from the <see cref="T:Ncqrs.Domain.Mapping.ConventionBasedDomainEventHandlerMappingStrategy" />.
            </summary>
    </member>
    <member name="T:Ncqrs.Domain.Mapping.EventHandlerAttribute">
      <summary>
            Indicates that a method is an event handler.
            </summary>
      <remarks>
            The marked method should not be static and should have on parameter that is of the type <see cref="T:Ncqrs.Domain.DomainEvent" />.
            </remarks>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingConfiguration">
      <summary>
            Helper methods to get properties and parameter values from commands.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingConfiguration.GetParameterValues(Ncqrs.Commanding.ICommand,System.Reflection.ParameterInfo[])">
      <summary>
            Gets all the values for the parameters filled with the values from the command.
            </summary>
      <param name="command">The command.</param>
      <param name="parameters">The parameters.</param>
      <returns>All the values for the parameters.</returns>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingConfiguration.GetPropertyValueBasedOnParameterInfo(Ncqrs.Commanding.ICommand,System.Reflection.ParameterInfo)">
      <summary>
            Gets the property value from the first matched property. The match is made by the name and the type of the specified parameter.
            </summary>
      <remarks>The property match is done by the name and type, where the name is matched case insensitive and the type of the 
            parameter type should be assignable from the property type.</remarks>
      <param name="command">The command.</param>
      <param name="parameterInfo">The parameter info.</param>
      <exception cref="T:System.ArgumentNullException">Thrown when <i>command</i> or <i>parameterInfo</i> is null.</exception>
      <returns>The value from the first matched property.</returns>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingConfiguration.GetCommandProperties(Ncqrs.Commanding.ICommand)">
      <summary>
            Gets all the properties from the command that should be used in the auto mapping process.
            </summary>
      <remarks>All properties marked with the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.ExcludeInMappingAttribute" /> are ignored.</remarks>
      <param name="command">The command.</param>
      <exception cref="T:System.ArgumentNullException">Thrown when <i>command</i> is null.</exception>
      <returns>A result set containing all properties that should be used in the auto mapping process.</returns>
    </member>
    <member name="T:Ncqrs.Eventing.Conversion.EventConverter">
      <summary>
            A dispatcher that dispatch event conversion to the converters that have been added based on event type.
            When an event should be converted it resolved the corresponding converter and uses that one to convert the event. When there
            is also a converter that can convert the result of that conversion that one is called.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Conversion.IEventConverter`2">
      <summary>
            Converts an event into another event.
            <para>
            This can be used to handle changes in events. Instead of changing an
            existing event by for example adding a new property to it you should
            introduce a new event. When you have done this you should create a
            converter that can convert all the old to events to the new introduced
            event.
            </para></summary>
    </member>
    <member name="M:Ncqrs.Eventing.Conversion.IEventConverter`2.Convert(`0)">
      <summary>
            Converts an event. It return a new transformed event based on the 
            <paramref name="eventToConvert" />. The 
            <see cref="P:Ncqrs.Eventing.ISourcedEvent.EventSourceId" />, 
            <see cref="P:Ncqrs.Eventing.ISourcedEvent.EventSequence" />, 
            <see cref="!:ISourcedEvent.EventIdentifier" /> and the 
            <see cref="!:ISourcedEvent.EventTimeStamp" /> should stay the same.
            </summary>
      <param name="eventToConvert">The event to convert.</param>
      <returns>A new event based on the <paramref name="eventToConvert" />.
            </returns>
    </member>
    <member name="M:Ncqrs.Eventing.Conversion.EventConverter.AddConverter``2(System.Converter{``0,``1})">
      <summary>
            Adds the converter for a specific event type.
            </summary>
      <typeparam name="TFrom">The type of the event that will be converted.</typeparam>
      <typeparam name="TTo">The type of the result of the conversion.</typeparam>
      <param name="converter">The converter method that does the conversion.</param>
      <returns>The current <see cref="T:Ncqrs.Eventing.Conversion.EventConverter" /> that can be used to chain method calls.</returns>
      <requires description="The converter cannot be null." exception="T:System.ArgumentNullException">converter != null</requires>
      <exception cref="T:System.ArgumentNullException">converter == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Conversion.EventConverter.AddConverter``2(Ncqrs.Eventing.Conversion.IEventConverter{``0,``1})">
      <summary>
            Adds the converter for a specific event type.
            </summary>
      <param name="eventSourceType">The type of the event that will be converted.</param>
      <param name="converter">The converter method that does the conversion.</param>
      <returns>The current <see cref="T:Ncqrs.Eventing.Conversion.EventConverter" /> that can be used to chain method calls.</returns>
      <requires description="The converter cannot be null." exception="T:System.ArgumentNullException">converter != null</requires>
      <exception cref="T:System.ArgumentNullException">converter == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Conversion.EventConverter.Convert(Ncqrs.Eventing.ISourcedEvent)">
      <summary>
            Converts an event. It uses all converters available to convert the given event. That means that when an event of Evnt_V1 is given and there are converters
            that can convert Evnt_V1 intro Evnt_V2 and Evnt_V2 in Evnt_V3, the result of this method is a conversion from Evnt_V1 to Evnt_V3.
            </summary>
      <param name="eventToConvert">The event to convert.</param>
      <returns>
            A new event based on the <paramref name="eventToConvert" />.
            </returns>
    </member>
    <member name="T:Ncqrs.DateTimeBasedClock">
      <summary>
            A clock that is based on the <see cref="T:System.DateTime" /> class from the .NET framework.
            </summary>
    </member>
    <member name="T:Ncqrs.IClock">
      <summary>
            Represents a clock that can give the current time.
            </summary>
    </member>
    <member name="M:Ncqrs.IClock.UtcNow">
      <summary>
            Gets the current UTC date and time from the clock.
            </summary>
      <returns>The current UTC date and time.</returns>
      <ensures description="The result should be a UTC date and time.">Contract.Result&lt;DateTime&gt;().Kind == DateTimeKind.Utc</ensures>
    </member>
    <member name="M:Ncqrs.DateTimeBasedClock.UtcNow">
      <summary>
            Gets the current UTC date and time from the clock.
            </summary>
      <returns>The current UTC date and time.</returns>
      <ensures description="The result should be a UTC date and time." inheritedFrom="M:Ncqrs.IClock.UtcNow" inheritedFromTypeName="IClock">Contract.Result&lt;DateTime&gt;().Kind == DateTimeKind.Utc</ensures>
    </member>
    <member name="T:Ncqrs.Commanding.ServiceModel.InProcessCommandService">
      <summary>
            A in process command service.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.CommandServiceBase.Execute(Ncqrs.Commanding.ICommand)">
      <summary>
            Execute a <see cref="T:Ncqrs.Commanding.ICommand" /> by giving it to the registered <see cref="!:ICommandExecutor" />.
            </summary>
      <param name="command">The command to execute.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when the <i>command</i> was a <c>null</c> dereference.</exception>
      <exception cref="T:Ncqrs.Commanding.CommandExecution.CommandExecutorNotFoundException">Occurs when the <see cref="T:Ncqrs.Commanding.CommandExecution.ICommandExecutor`1" /> was not found for on the given <see cref="T:Ncqrs.Commanding.ICommand" />.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.CommandServiceBase.RegisterExecutor``1(Ncqrs.Commanding.CommandExecution.ICommandExecutor{``0})">
      <summary>
            Registers the executor for the specified command type. The executor will be called for every command of the specified type.
            </summary>
      <typeparam name="TCommand">The type of the command.</typeparam>
      <param name="executor">The executor that will be called for every command of the specified type.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when the <i>commandType</i> or <i>executor</i> was a <c>null</c> dereference.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.CommandServiceBase.UnregisterExecutor``1">
      <summary>
            Unregisters the executor of the specified command type. The executor will not be called any more.
            </summary>
      <param name="executor">The executor to unregister.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when the <i>commandType</i> or <i>executor</i> was a <c>null</c> dereference.</exception>
      <exception cref="T:System.InvalidOperationException">Occurs when the <i>executor</i> is not the same as the registered executor for the specified command type.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.CommandServiceBase.GetCommandExecutorForCommand(System.Type)">
      <summary>
            Gets the command executor for command.
            </summary>
      <param name="commandType">Type of the command.</param>
      <returns>
            A command executor to use to execute the command or <c>null</c> if not found.
            </returns>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.CommandServiceBase.AddInterceptor(Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor)">
      <summary>
            Adds the interceptor. The interceptor will be called on every
            command execution.
            </summary>
      <remarks>
            When the interceptor was already added to this command service, it
            is skipped. That means that it is not added twice.
            </remarks>
      <param name="interceptor">The interceptor to add.</param>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.CommandServiceBase.RemoveInterceptor(Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor)">
      <summary>
            Removes the interceptor. The interceptor will not be called anymore.
            </summary>
      <param name="interceptor">The interceptor to remove.</param>
    </member>
    <member name="T:Ncqrs.LogManager">
      <summary>
            A manager class to use to get a logger for a certain type.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Snapshot">
      <summary>
            Holds the full state of an <see cref="T:Ncqrs.Eventing.IEventSource" /> at a certain version.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.ISnapshot">
      <summary>
            Holds the full state of an <see cref="T:Ncqrs.Eventing.IEventSource" /> at a certain version.
            </summary>
    </member>
    <member name="P:Ncqrs.Eventing.ISnapshot.EventSourceId">
      <summary>
            Gets the event source id.
            </summary>
      <value>The event source id.</value>
    </member>
    <member name="P:Ncqrs.Eventing.ISnapshot.EventSourceVersion">
      <summary>
            Gets the version of the event source from when this snapshot was created.
            </summary>
      <value>The event source version.</value>
    </member>
    <member name="P:Ncqrs.Eventing.Snapshot.EventSourceId">
      <summary>
            Gets the id of the event source from which this snapshot was created.
            </summary>
      <remarks>
            The id of the event source from which this snapshot was created.
            </remarks>
    </member>
    <member name="P:Ncqrs.Eventing.Snapshot.EventSourceVersion">
      <summary>
            Gets the version of the event source when this snapshot was created.
            </summary>
      <value>The version of the event source when this snapshot was created.</value>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Actions.DirectMethodCommandInfo.#ctor(Ncqrs.Commanding.ICommand,System.Type,System.Guid,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Actions.DirectMethodCommandInfo" /> struct.
            </summary>
      <param name="command">The command.</param>
      <param name="aggregateType">Type of the aggregate.</param>
      <param name="aggregateRootIdValue">The aggregate root id.</param>
      <param name="methodName">Name of the method.</param>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.Mapping.Actions.DirectMethodCommandInfo.AggregateType">
      <summary>
            Gets the type of the aggregate root.
            </summary>
      <value>The type of the aggregate root.</value>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.Mapping.Actions.DirectMethodCommandInfo.AggregateRootIdValue">
      <summary>
            Gets the aggregate root id.
            </summary>
      <value>The id of the aggregate root.</value>
    </member>
    <member name="T:Ncqrs.Domain.Mapping.ExpressionHandler">
      <summary>
            The base implementation for the handling of expression based mapping.
            </summary>
    </member>
    <member name="P:Ncqrs.Domain.Mapping.ExpressionHandler.ActionMethodInfo">
      <summary>
            Gets the action that is to be invoked.
            </summary>
    </member>
    <member name="P:Ncqrs.Domain.Mapping.ExpressionHandler.Exact">
      <summary>
            Gets the value that determines if the given mapping should match exactly.
            </summary>
    </member>
    <member name="T:Ncqrs.Domain.Mapping.ExpressionHandler`1">
      <summary>
            The generic base implementation for the handling of expression based mapping.
            </summary>
      <typeparam name="T">This should always be a <see cref="T:Ncqrs.Domain.DomainEvent" />.</typeparam>
    </member>
    <member name="M:Ncqrs.Domain.Mapping.ExpressionHandler`1.ToHandler(System.Action{`0})">
      <summary>
            Stores the given <see cref="T:System.Action`1" /> action.
            </summary>
      <param name="mappingaction">The <see cref="T:System.Action`1" /> to map.</param>
      <returns>Itself <see cref="T:Ncqrs.Domain.Mapping.ExpressionHandler`1" />.</returns>
      <requires description="The mappingaction can not be null." exception="T:System.ArgumentNullException">mappingaction != null</requires>
      <exception cref="T:System.ArgumentNullException">mappingaction == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.Mapping.ExpressionHandler`1.MatchExact">
      <summary>
            Determines that the action should map <b>exactly</b> on the given method in the given type.
            </summary>
    </member>
    <member name="T:Ncqrs.Domain.Mapping.AttributeBasedDomainEventHandlerMappingStrategy">
      <summary>
            An internal event handler mapping strategy that creates event handlers based on mapping that
            is done by attributes.
            <remarks>Use the <see cref="T:Ncqrs.Domain.Mapping.EventHandlerAttribute" /> to mark event handler methods as an event handler. You can only
            mark methods that following rules:
            <list type="number"><item><description>The method should be an instance method (no static).</description></item><item><description>It should accept 1 parameter.</description></item><item><description>The parameter should be, or inherited from, the <see cref="T:Ncqrs.Domain.DomainEvent" /> class.</description></item><item><description>The method should be marked with the <see cref="T:Ncqrs.Domain.Mapping.EventHandlerAttribute" />.</description></item></list><code>public class Foo : AggregateRootMappedWithAttributes
            {
                [EventHandler]
                private void onFooEvent(FooEvent eventToHandle)
                {
                    // ...
                }
            }</code></remarks></summary>
    </member>
    <member name="M:Ncqrs.Domain.Mapping.AttributeBasedDomainEventHandlerMappingStrategy.GetEventHandlersFromAggregateRoot(Ncqrs.Domain.AggregateRootMappedWithAttributes)">
      <summary>
            Gets the event handlers from aggregate root based on attributes.
            </summary>
      <param name="aggregateRoot">The aggregate root.</param>
      <see cref="T:Ncqrs.Domain.Mapping.AttributeBasedDomainEventHandlerMappingStrategy" />
      <returns>All the <see cref="T:Ncqrs.Domain.IDomainEventHandler" />'s created based on attribute mapping.</returns>
      <requires description="The aggregateRoot cannot be null." exception="T:System.ArgumentNullException">aggregateRoot != null</requires>
      <exception cref="T:System.ArgumentNullException">aggregateRoot == null</exception>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.ConcurrencyException">
      <summary>
            Occurs when there is already a newer version of the event source stored in the event store.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.ConcurrencyException.#ctor(System.Guid,System.Int64)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Eventing.Storage.ConcurrencyException" /> class.
            </summary>
      <param name="eventSourceId">The id of the event source.</param>
      <param name="providerVersion">The event source version.</param>
      <param name="versionInStore">The version in store.</param>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.ConcurrencyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Eventing.Storage.ConcurrencyException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Ncqrs.Eventing.Storage.ConcurrencyException.EventSourceId">
      <summary>
            Gets the id of the event source.
            </summary>
      <value>The id event source.</value>
    </member>
    <member name="P:Ncqrs.Eventing.Storage.ConcurrencyException.EventSourceVersion">
      <summary>
            Gets the event source version.
            </summary>
      <value>The event source version.</value>
    </member>
    <member name="T:Ncqrs.Domain.TypeThresholdedActionBasedDomainEventHandler">
      <summary>
              An event handler that uses a specified action as handler, but only calls this when the event
              is of a certain type, or is inherited from it.
            </summary>
      <invariant>_handler != null</invariant>
      <invariant>_eventTypeThreshold != null</invariant>
    </member>
    <member name="F:Ncqrs.Domain.TypeThresholdedActionBasedDomainEventHandler._eventTypeThreshold">
      <summary>
              The event type that should be used as threshold.
            </summary>
    </member>
    <member name="F:Ncqrs.Domain.TypeThresholdedActionBasedDomainEventHandler._exact">
      <summary>
              Specifies whether the event type threshold should be used as an exact or at least threshold.
            </summary>
      <remarks>
        <c>true</c> means that the event type threshold should be the same type as the event, otherwise
              the event handler will not be executed. <c>false</c> means that the threshold type should be in 
              the inheritance hierarchy of the event type, or that the threshold type should be an interface 
              that the event type implements, otherwise the handler will not be executed.
            </remarks>
    </member>
    <member name="F:Ncqrs.Domain.TypeThresholdedActionBasedDomainEventHandler._handler">
      <summary>
              The handler that should be called when the threshold did not hold the event.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.TypeThresholdedActionBasedDomainEventHandler.#ctor(System.Action{Ncqrs.Domain.DomainEvent},System.Type,System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Ncqrs.Domain.TypeThresholdedActionBasedDomainEventHandler" /> class.
            </summary>
      <param name="handler">The handler that will be called to handle a event when the threshold did not hold the event.</param>
      <param name="eventTypeThreshold">The event type that should be used as threshold.</param>
      <param name="exact">if set to <c>true</c> the threshold will hold all types that are not the same type; otherwise it hold 
            all types that are not inhered from the event type threshold or implement the interface that is specified by the threshold type.</param>
      <requires description="The handler cannot be null." exception="T:System.ArgumentNullException">handler != null</requires>
      <exception cref="T:System.ArgumentNullException">handler == null</exception>
      <requires description="The eventTypeThreshold cannot be null." exception="T:System.ArgumentNullException">eventTypeThreshold != null</requires>
      <exception cref="T:System.ArgumentNullException">eventTypeThreshold == null</exception>
      <requires description="The eventTypeThreshold should be of a type that implements the IEvent interface." exception="T:System.ArgumentException">typeof(DomainEvent).IsAssignableFrom(eventTypeThreshold)</requires>
      <exception cref="T:System.ArgumentException">!(typeof(DomainEvent).IsAssignableFrom(eventTypeThreshold))</exception>
    </member>
    <member name="M:Ncqrs.Domain.TypeThresholdedActionBasedDomainEventHandler.HandleEvent(Ncqrs.Domain.DomainEvent)">
      <summary>
              Handles the event.
            </summary>
      <param name="evnt">The event to handle.
              <remarks>
                This value should not be <c>null</c>.
              </remarks></param>
      <returns>
        <c>true</c> when the event was handled; otherwise, <c>false</c>.
              <remarks><c>false</c> does not mean that the handling failed, but that the
                handler was not interested in handling this event.
              </remarks></returns>
      <requires description="The evnt cannot be null." exception="T:System.ArgumentNullException">evnt != null</requires>
      <exception cref="T:System.ArgumentNullException">evnt == null</exception>
      <requires description="The evnt cannot be null." inheritedFrom="M:Ncqrs.Domain.IDomainEventHandler.HandleEvent(Ncqrs.Domain.DomainEvent)" inheritedFromTypeName="IDomainEventHandler" exception="T:System.ArgumentNullException">evnt != null</requires>
      <exception cref="T:System.ArgumentNullException">evnt == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.TypeThresholdedActionBasedDomainEventHandler.ObjectInvariants">
      <summary>
              This method holds all the objects invariants.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.TypeThresholdedActionBasedDomainEventHandler.ShouldHandleThisEvent(Ncqrs.Domain.DomainEvent)">
      <summary>
              Determine whether the event should be handled or not.
            </summary>
      <param name="evnt">The event.</param>
      <returns>
        <c>true</c> when this event should be handled; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Actions.ObjectCreationCommandInfo.#ctor(Ncqrs.Commanding.ICommand,System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Actions.ObjectCreationCommandInfo" /> struct.
            </summary>
      <param name="command">The command.</param>
      <param name="aggregateType">Type of the aggregate.</param>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.Mapping.Actions.ObjectCreationCommandInfo.AggregateType">
      <summary>
            Gets the type of the aggregate root.
            </summary>
      <value>The type of the aggregate root.</value>
    </member>
    <member name="F:Ncqrs.Domain.UnitOfWork._threadInstance">
      <summary>
            The <see cref="T:Ncqrs.Domain.UnitOfWork" /> that is associated with the current thread.
            </summary>
    </member>
    <member name="F:Ncqrs.Domain.UnitOfWork._dirtyInstances">
      <summary>
            A queue that holds a reference to all instances that have themself registered as a dirty instance during the lifespan of this unit of work instance.
            </summary>
    </member>
    <member name="F:Ncqrs.Domain.UnitOfWork._repository">
      <summary>
            A reference to the repository that is associated with this instance.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.UnitOfWork.#ctor(Ncqrs.Domain.Storage.IDomainRepository)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Domain.UnitOfWork" /> class.
            </summary>
      <param name="domainRepository">The domain repository to use in this unit of work.</param>
      <requires description="An other UnitOfWork instance already exists in this context." exception="T:System.InvalidOperationException">Current == null</requires>
      <exception cref="T:System.InvalidOperationException">Current != null</exception>
      <requires exception="T:System.ArgumentNullException">domainRepository != null</requires>
      <exception cref="T:System.ArgumentNullException">domainRepository == null</exception>
      <ensures description="The _repository member should be initialized with the one given by the domainRepository parameter.">_repository == domainRepository</ensures>
      <ensures description="The _threadInstance member should be initialized with this instance.">_threadInstance == this</ensures>
      <ensures>IsDisposed == false</ensures>
    </member>
    <member name="M:Ncqrs.Domain.UnitOfWork.Finalize">
      <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:Ncqrs.Domain.UnitOfWork" /> is reclaimed by garbage collection.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.UnitOfWork.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <ensures>IsDisposed == true</ensures>
    </member>
    <member name="M:Ncqrs.Domain.UnitOfWork.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
      <ensures>IsDisposed == true</ensures>
    </member>
    <member name="M:Ncqrs.Domain.UnitOfWork.RegisterDirtyInstance(Ncqrs.Domain.AggregateRoot)">
      <summary>
            Registers the dirty.
            </summary>
      <param name="dirtyInstance">The dirty instance.</param>
      <requires description="dirtyInstance could not be null." exception="T:System.ArgumentNullException">dirtyInstance != null</requires>
      <exception cref="T:System.ArgumentNullException">dirtyInstance == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.UnitOfWork.Accept">
      <summary>
            Accepts the unit of work and persist the changes.
            </summary>
      <requires exception="T:System.ObjectDisposedException">!IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
      <ensures>_dirtyInstances.Count == 0</ensures>
    </member>
    <member name="P:Ncqrs.Domain.UnitOfWork.Current">
      <summary>
            Gets the <see cref="T:Ncqrs.Domain.UnitOfWork" /> associated with the current thread context.
            </summary>
      <value>The current.</value>
    </member>
    <member name="P:Ncqrs.Domain.UnitOfWork.IsDisposed">
      <summary>
            Gets or sets a value indicating whether this instance is disposed.
            </summary>
      <value>
        <c>true</c> if this instance is disposed; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Ncqrs.Domain.UnitOfWork.Repository">
      <summary>
            Gets the domain repository.
            </summary>
      <value>The domain repository.</value>
    </member>
    <member name="T:Ncqrs.Eventing.ISnapshotable`1">
      <summary>
            This interface flags an object beeing <i>snapshotable</i>. This means
            that the state of the object could be saved to an 
            <see cref="T:Ncqrs.Eventing.ISnapshot" /> object and restored from a the from the same
            class. This is used to prevent building <see cref="T:Ncqrs.Domain.AggregateRoot" />'s
            from the ground up.
            </summary>
      <remarks>
            Only one <see cref="T:Ncqrs.Eventing.ISnapshotable`1" /> can be implemented. If
            you implement more than one, it will cause an exception when saving this
            instance.
            </remarks>
    </member>
    <member name="T:Ncqrs.Eventing.EventBase">
      <summary>
            The base for all event messages.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.EventBase.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Eventing.EventBase" /> class.
            </summary>
    </member>
    <member name="P:Ncqrs.Eventing.EventBase.EventIdentifier">
      <summary>
            Gets the unique identifier for this event.
            </summary>
    </member>
    <member name="P:Ncqrs.Eventing.EventBase.EventTimeStamp">
      <summary>
            Gets the time stamp for this event.
            </summary>
      <value>a <see cref="T:System.DateTime" /> UTC value that represents the point
            in time where this event occurred.</value>
      <getter>
        <ensures description="The event time stamp should always be in a UTC kind." inheritedFrom="M:Ncqrs.Eventing.IEvent.get_EventTimeStamp" inheritedFromTypeName="IEvent">Contract.Result&lt;DateTime&gt;().Kind == DateTimeKind.Utc</ensures>
      </getter>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.ActionFactory">
      <summary>
            A factory to use the create action for commands based on mapping.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.ActionFactory.CreateExecutorForCommand``1(``0)">
      <summary>
            Creates an executor for command based on mapping.
            </summary>
      <param name="command">The command.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <i>command</i> was <c>null</c>.</exception>
      <exception cref="T:Ncqrs.Commanding.CommandExecution.Mapping.MappingForCommandNotFoundException">Occurs when there was an error in the mapping of the command.</exception>
      <returns>A <see cref="!:ICommandExecutor" /> created based on the mapping of the command.</returns>
      <requires exception="T:System.ArgumentNullException">command != null</requires>
      <exception cref="T:System.ArgumentNullException">command == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.ActionFactory.IsCommandMappedToADirectMethod(Ncqrs.Commanding.ICommand)">
      <summary>
            Determines whether the command is mapped to a direct method.
            </summary>
      <param name="command">The command.</param>
      <returns>
        <c>true</c> if the command is mapped to a direct method; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.ActionFactory.IsCommandMappedToObjectCreation(Ncqrs.Commanding.ICommand)">
      <summary>
            Determines whether the command is mapped for object creation.
            </summary>
      <param name="command">The command.</param>
      <returns>
        <c>true</c> if the is command mapped for object creation; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.ActionFactory.IsAttributeDefinedOnCommand``1(Ncqrs.Commanding.ICommand)">
      <summary>
            Determines whether the specified attribute is defined on the command.
            </summary>
      <typeparam name="T">The type of the attribute.</typeparam>
      <param name="command">The command.</param>
      <returns>
        <c>true</c> if the specified attribute is defined on the given command; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.InMemoryEventStore">
      <summary>
            An in memory event store that can be used for unit testing purpose. We can't
            think of any situation where you want to use this in production.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.InMemoryEventStore.GetAllEventsSinceVersion(System.Guid,System.Int64)">
      <summary>
            Get all events provided by an specified event source.
            </summary>
      <param name="eventSourceId">The id of the event source that owns the events.</param>
      <returns>All the events from the event source.</returns>
      <ensures inheritedFrom="M:Ncqrs.Eventing.Storage.IEventStore.GetAllEventsSinceVersion(System.Guid,System.Int64)" inheritedFromTypeName="IEventStore">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ISourcedEvent&gt;&gt;(), e =&gt; e.EventSequence &gt; version)</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.InMemoryEventStore.SaveShapshot(Ncqrs.Eventing.ISnapshot)">
      <summary>
            Saves a snapshot of the specified event source.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.InMemoryEventStore.GetSnapshot(System.Guid)">
      <summary>
            Gets a snapshot of a particular event source, if one exists. Otherwise, returns <c>null</c>.
            </summary>
    </member>
    <!-- Badly formed XML comment ignored for member "T:Ncqrs.Domain.AggregateRootMappedByConvention" -->
    <member name="M:Ncqrs.Domain.AggregateRootMappedByConvention.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Domain.AggregateRootMappedByConvention" /> class.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Conversion.DelegateBasedConverter`2">
      <summary>
            A converter that uses a <see cref="T:System.Converter`2" /> delegate to execute the actual conversion.
            <para>
            The
            <see cref="P:Ncqrs.Eventing.ISourcedEvent.EventSourceId" />,
            <see cref="P:Ncqrs.Eventing.ISourcedEvent.EventSequence" />,
            <see cref="!:ISourcedEvent.EventIdentifier" /> and the
            <see cref="!:ISourcedEvent.EventTimeStamp" /> should stay the same.
            </para></summary>
      <typeparam name="TFrom">The type of the event that will be converted.</typeparam>
      <typeparam name="TTo">The type of the result of the conversion.</typeparam>
    </member>
    <member name="M:Ncqrs.Eventing.Conversion.DelegateBasedConverter`2.#ctor(System.Converter{`0,`1})">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Eventing.Conversion.DelegateBasedConverter`2" /> class.
            </summary>
      <param name="converter">The converter that will do the actual conversion.</param>
      <requires description="The converter cannot be null." exception="T:System.ArgumentNullException">converter != null</requires>
      <exception cref="T:System.ArgumentNullException">converter == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Conversion.DelegateBasedConverter`2.Convert(`0)">
      <summary>
            Converts an event. It return a new transformed event based on the
            <paramref name="eventToConvert" />. The
            <see cref="P:Ncqrs.Eventing.ISourcedEvent.EventSourceId" />,
            <see cref="P:Ncqrs.Eventing.ISourcedEvent.EventSequence" />,
            <see cref="!:ISourcedEvent.EventIdentifier" /> and the
            <see cref="!:ISourcedEvent.EventTimeStamp" /> should stay the same.
            </summary>
      <param name="eventToConvert">The event to convert.</param>
      <returns>
            A new event based on the <paramref name="eventToConvert" />.
            </returns>
    </member>
    <member name="T:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException">
      <summary>
            Thrown when a <see cref="!:IUnitOfWork" /> is requested but was not available in the context.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException" /> class.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="inner">The inner exception.</param>
    </member>
    <member name="M:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="info" /> parameter is null.
            </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0).
            </exception>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.CommandExecutorBase`1">
      <summary>
             Represents a command executor.
             </summary>
      <code lang="c#">
             public class AddProductToShoppingCartExecutor : CommandExecutorBase
             {
                 protected override void ExecuteInContext(IUnitOfWorkContext context, AddProductToShoppingCart command)
                 {
                     // Get the shopping cart.
                     var shoppingCart = context.GetById(command.ShoppingCartId);
             
                     // Add the product to the shopping cart.
                     shoppingCart.AddProduct(command.ProductId, command.Amount);
            
                     // Accept all the work we just did.
                     context.Accept();
                 }
             }
             </code>
      <typeparam name="TCommand">The type of the commands to execute.</typeparam>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.CommandExecutorBase`1.Execute(`0)">
      <summary>
            Executes the command.
            </summary>
      <param name="command">The command to execute. This should not be null.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <i>command</i> is null.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.CommandExecutorBase`1.ExecuteInContext(Ncqrs.Domain.IUnitOfWorkContext,`0)">
      <summary>
             Executes the command withing an unit of work context.
             <remarks>Make sure you call <see cref="M:Ncqrs.Domain.IUnitOfWorkContext.Accept" /> to accept the changes that has been made in the context.</remarks></summary>
      <example>
        <code lang="c#">
             public class AddProductToShoppingCartExecutor : CommandExecutorBase
             {
                 protected override void ExecuteInContext(IUnitOfWorkContext context, AddProductToShoppingCart command)
                 {
                     // Get the shopping cart.
                     var shoppingCart = context.GetById(command.ShoppingCartId);
             
                     // Add the product to the shopping cart.
                     shoppingCart.AddProduct(command.ProductId, command.Amount);
            
                     // Accept all the work we just did.
                     context.Accept();
                 }
             }
             </code>
      </example>
      <param name="context">The work context.</param>
      <param name="command">The command to execute.</param>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Actions.DirectMethodCommandExecutor`1">
      <summary>
            An auto mapped action that executes a method on an aggregate root based on the mapping specified on the command.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Actions.DirectMethodCommandExecutor`1.Execute(`0)">
      <summary>
            Executes this method on the aggregate root based on the mapping of the command given a construction time.
            </summary>
    </member>
    <member name="T:Ncqrs.Commanding.CommandBase">
      <summary>
            The base of a command message. A command should contain all the
            information and intend that is needed to execute an corresponding
            action.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandBase.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandBase" /> class.
            </summary>
      <remarks>
            This uses the <see cref="M:Ncqrs.NcqrsEnvironment.Get``1" /> to get
            the generator to use to generate the command identifier.
            </remarks>
    </member>
    <member name="P:Ncqrs.Commanding.CommandBase.CommandIdentifier">
      <summary>
            Gets the unique identifier for this command.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.DomainEventHandler`1.Ncqrs#Domain#IDomainEventHandler#HandleEvent(Ncqrs.Domain.DomainEvent)">
      <requires description="The evnt cannot be null." inheritedFrom="M:Ncqrs.Domain.IDomainEventHandler.HandleEvent(Ncqrs.Domain.DomainEvent)" inheritedFromTypeName="IDomainEventHandler" exception="T:System.ArgumentNullException">evnt != null</requires>
      <exception cref="T:System.ArgumentNullException">evnt == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.Storage.DomainRepository.GetById(System.Type,System.Guid)">
      <requires inheritedFrom="M:Ncqrs.Domain.Storage.IDomainRepository.GetById(System.Type,System.Guid)" inheritedFromTypeName="IDomainRepository" exception="T:System.ArgumentNullException">aggregateRootType != null</requires>
      <exception cref="T:System.ArgumentNullException">aggregateRootType == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.Storage.DomainRepository.Save(Ncqrs.Domain.AggregateRoot)">
      <requires inheritedFrom="M:Ncqrs.Domain.Storage.IDomainRepository.Save(Ncqrs.Domain.AggregateRoot)" inheritedFromTypeName="IDomainRepository" exception="T:System.ArgumentNullException">aggregateRootToSave != null</requires>
      <exception cref="T:System.ArgumentNullException">aggregateRootToSave == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.Storage.DomainRepository.#ctor(Ncqrs.Eventing.Storage.IEventStore,Ncqrs.Eventing.ServiceModel.Bus.IEventBus,Ncqrs.Eventing.Storage.ISnapshotStore,Ncqrs.Eventing.Conversion.IEventConverter{Ncqrs.Domain.DomainEvent,Ncqrs.Domain.DomainEvent})">
      <requires exception="T:System.ArgumentNullException">store != null</requires>
      <exception cref="T:System.ArgumentNullException">store == null</exception>
      <requires exception="T:System.ArgumentNullException">eventBus != null</requires>
      <exception cref="T:System.ArgumentNullException">eventBus == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.Mapping.ConventionBasedDomainEventHandlerMappingStrategy.GetEventHandlersFromAggregateRoot(Ncqrs.Domain.AggregateRootMappedByConvention)">
      <requires description="The aggregateRoot cannot be null." exception="T:System.ArgumentNullException">aggregateRoot != null</requires>
      <exception cref="T:System.ArgumentNullException">aggregateRoot == null</exception>
      <ensures description="The result should never be null.">Contract.Result&lt;IEnumerable&lt;IDomainEventHandler&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Ncqrs.Domain.Mapping.MappedAggregateRoot`1.#ctor(Ncqrs.Domain.Mapping.IDomainEventHandlerMappingStrategy{`0})">
      <requires description="The strategy cannot be null." exception="T:System.ArgumentNullException">strategy != null</requires>
      <exception cref="T:System.ArgumentNullException">strategy == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.Mapping.AttributeBasedDomainEventHandlerMappingStrategy.IsMarkedAsEventHandler(System.Reflection.MethodInfo,Ncqrs.Domain.Mapping.EventHandlerAttribute@)">
      <requires description="The target cannot be null." exception="T:System.ArgumentNullException">target != null</requires>
      <exception cref="T:System.ArgumentNullException">target == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.Mapping.AttributeBasedDomainEventHandlerMappingStrategy.NumberOfParameters(System.Reflection.MethodInfo)">
      <requires description="The target cannot be null." exception="T:System.ArgumentNullException">target != null</requires>
      <exception cref="T:System.ArgumentNullException">target == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.Mapping.AttributeBasedDomainEventHandlerMappingStrategy.FirstParameterType(System.Reflection.MethodInfo)">
      <requires description="The target cannot be null." exception="T:System.ArgumentNullException">target != null</requires>
      <exception cref="T:System.ArgumentNullException">target == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.AggregateRoot.GetUncommittedEvents">
      <ensures description="The result of this method should never be null.">Contract.Result&lt;IEnumerable&lt;DomainEvent&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Ncqrs.Domain.AggregateRoot.HandleEvent(Ncqrs.Domain.DomainEvent)">
      <requires description="The evnt cannot be null." exception="T:System.ArgumentNullException">evnt != null</requires>
      <exception cref="T:System.ArgumentNullException">evnt == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.AggregateRoot.RegisterHandler(Ncqrs.Domain.IDomainEventHandler)">
      <requires description="The handler cannot be null." exception="T:System.ArgumentNullException">handler != null</requires>
      <exception cref="T:System.ArgumentNullException">handler == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.InMemoryEventStore.Save(Ncqrs.Eventing.IEventSource)">
      <requires description="source cannot be null." inheritedFrom="M:Ncqrs.Eventing.Storage.IEventStore.Save(Ncqrs.Eventing.IEventSource)" inheritedFromTypeName="IEventStore" exception="T:System.ArgumentNullException">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Actions.ObjectCreationCommandInfo.CreateFromDirectMethodCommand(Ncqrs.Commanding.ICommand)">
      <ensures description="The result of the method should not be null.">Contract.Result&lt;ObjectCreationCommandInfo&gt;() != null</ensures>
    </member>
  </members>
</doc>